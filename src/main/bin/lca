#!/usr/bin/env bash
set -euo pipefail

REPO="Alipsa/local-coding-assistant"
LIB_DIR="${HOME}/.local/lib"
JAR_PREFIX="local-coding-assistant"
JAR_PATTERN="${JAR_PREFIX}-*-exec.jar"
API_URL="https://api.github.com/repos/${REPO}/releases/latest"
MODELS=(
  "qwen3-coder:30b"
  "gpt-oss:20b"
)

die() {
  echo "Error: $*" >&2
  exit 1
}

usage() {
  cat <<'EOF'
Usage:
  lca                         Run the local coding assistant (download if missing)
  lca upgrade                 Download the latest release if newer than the local jar
  lca upgrade --include <dir> Check for newer jars in <dir> before downloading
  lca install <jar>           Install a local jar file to ~/.local/lib
  lca --help                  Show this message
EOF
}

require_command() {
  local command_name="$1"
  if ! command -v "$command_name" >/dev/null 2>&1; then
    die "Required command '$command_name' is not available."
  fi
}

detect_os() {
  case "$(uname -s)" in
    Darwin)
      printf '%s\n' "mac"
      ;;
    Linux)
      printf '%s\n' "linux"
      ;;
    CYGWIN*|MINGW*|MSYS*)
      printf '%s\n' "windows"
      ;;
    *)
      die "Unsupported operating system."
      ;;
  esac
}

install_ollama() {
  local os="$1"
  case "$os" in
    mac)
      echo "Installing ollama using Homebrew..."
      require_command brew
      brew install ollama
      ;;
    linux)
      echo "Installing ollama using curl..."
      if command -v curl >/dev/null 2>&1; then
        curl -fsSL https://ollama.ai/install.sh | sh
        return
      fi
      if command -v wget >/dev/null 2>&1; then
        wget -qO - https://ollama.ai/install.sh | sh
        return
      fi
      die "curl or wget is required to install ollama."
      ;;
    windows)
      die "Please install ollama manually by downloading it from https://ollama.ai"
      ;;
  esac
}

check_and_install_model() {
  local model="$1"
  echo "Checking for ${model} model..."
  local list_output
  list_output="$(ollama list 2>/dev/null || true)"
  if printf '%s\n' "$list_output" | awk '{print $1}' | grep -Fxq "$model"; then
    echo "${model} model is already installed."
  else
    echo "${model} model not found. Installing..."
    ollama pull "$model"
  fi
}

ensure_prerequisites() {
  local os
  os="$(detect_os)"
  echo "Detected OS: ${os}"
  if ! command -v ollama >/dev/null 2>&1; then
    echo "ollama could not be found"
    install_ollama "$os"
  fi
  local model
  for model in "${MODELS[@]}"; do
    check_and_install_model "$model"
  done
}

fetch_release_json() {
  if command -v curl >/dev/null 2>&1; then
    curl -fsSL "$API_URL"
    return
  fi
  if command -v wget >/dev/null 2>&1; then
    wget -qO - "$API_URL"
    return
  fi
  die "Either curl or wget must be installed to check GitHub releases."
}

download_file() {
  local url="$1"
  local output_path="$2"
  if command -v curl >/dev/null 2>&1; then
    curl -fsSL "$url" -o "$output_path"
    return
  fi
  if command -v wget >/dev/null 2>&1; then
    wget -qO "$output_path" "$url"
    return
  fi
  die "Either curl or wget must be installed to download releases."
}

fetch_release_info() {
  local json
  json="$(fetch_release_json)"
  LATEST_VERSION="$(printf '%s\n' "$json" | grep -m1 '"tag_name"' | sed -E 's/.*"tag_name": "v?([^"]+)".*/\1/')"
  LATEST_URL="$(printf '%s\n' "$json" | grep -E '"browser_download_url":' | grep 'local-coding-assistant-.*-exec\.jar' \
    | head -n1 | sed -E 's/.*"browser_download_url": "([^"]+)".*/\1/')"
  if [ -z "${LATEST_VERSION:-}" ] || [ -z "${LATEST_URL:-}" ]; then
    die "Unable to determine the latest release details from GitHub."
  fi
}

find_latest_local_jar() {
  if [ ! -d "$LIB_DIR" ]; then
    return 1
  fi
  local jars
  jars="$(find "$LIB_DIR" -maxdepth 1 -type f -name "${JAR_PATTERN}" 2>/dev/null | sort -V)"
  if [ -z "$jars" ]; then
    return 1
  fi
  printf '%s\n' "$jars" | tail -n1
}

version_from_jar() {
  local jar_path="$1"
  local jar_name
  jar_name="$(basename "$jar_path")"
  printf '%s\n' "$jar_name" | sed -E 's/^local-coding-assistant-(.*)-exec\.jar$/\1/'
}

is_newer_version() {
  local current_version="$1"
  local candidate_version="$2"
  if [ "$current_version" = "$candidate_version" ]; then
    return 1
  fi
  local newest
  newest="$(printf '%s\n%s\n' "$current_version" "$candidate_version" | sort -V | tail -n1)"
  [ "$newest" = "$candidate_version" ]
}

download_latest_release() {
  mkdir -p "$LIB_DIR"
  local file_name="${LATEST_URL##*/}"
  local target_path="${LIB_DIR}/${file_name}"
  download_file "$LATEST_URL" "$target_path"
  printf '%s\n' "$target_path"
}

remove_old_jars() {
  local keep_version="$1"
  if [ ! -d "$LIB_DIR" ]; then
    return
  fi
  local jar
  while IFS= read -r jar; do
    if [[ "$jar" != *"-${keep_version}-exec.jar" ]]; then
      echo "Removing old jar: $(basename "$jar")"
      rm -f "$jar"
    fi
  done < <(find "$LIB_DIR" -maxdepth 1 -type f -name "${JAR_PATTERN}" 2>/dev/null)
}

run_programme() {
  ensure_prerequisites
  echo "Starting local coding assistant..."
  require_command java

  # Ensure TERM is set for proper JLine terminal handling
  if [ -z "$TERM" ] || [ "$TERM" = "dumb" ]; then
    export TERM=xterm-256color
  fi

  local jar_path
  if jar_path="$(find_latest_local_jar)"; then
    exec java -Dorg.jline.terminal.dumb=false -Djline.terminal=unix -jar "$jar_path" "$@"
  fi
  fetch_release_info
  jar_path="$(download_latest_release)"
  exec java -Dorg.jline.terminal.dumb=false -Djline.terminal=unix -jar "$jar_path" "$@"
}

find_newest_jar_in_dir() {
  local search_dir="$1"
  if [ ! -d "$search_dir" ]; then
    return 1
  fi
  local jars
  jars="$(find "$search_dir" -maxdepth 1 -type f -name "${JAR_PREFIX}-*-exec.jar" 2>/dev/null | sort -V)"
  if [ -z "$jars" ]; then
    return 1
  fi
  printf '%s\n' "$jars" | tail -n1
}

get_file_mtime() {
  local file_path="$1"
  if [ ! -f "$file_path" ]; then
    echo "0"
    return
  fi
  case "$(uname -s)" in
    Darwin)
      stat -f %m "$file_path" 2>/dev/null || echo "0"
      ;;
    Linux)
      stat -c %Y "$file_path" 2>/dev/null || echo "0"
      ;;
    *)
      echo "0"
      ;;
  esac
}

is_newer_jar() {
  local current_jar="$1"
  local candidate_jar="$2"
  local current_version
  local candidate_version
  current_version="$(version_from_jar "$current_jar")"
  candidate_version="$(version_from_jar "$candidate_jar")"

  # If versions are different, use version comparison
  if [ "$current_version" != "$candidate_version" ]; then
    is_newer_version "$current_version" "$candidate_version"
    return $?
  fi

  # Same version - for SNAPSHOT, compare modification times
  if [[ "$candidate_version" =~ SNAPSHOT ]]; then
    local current_mtime
    local candidate_mtime
    current_mtime="$(get_file_mtime "$current_jar")"
    candidate_mtime="$(get_file_mtime "$candidate_jar")"
    [ "$candidate_mtime" -gt "$current_mtime" ]
    return $?
  fi

  # Same non-SNAPSHOT version, candidate is not newer
  return 1
}

upgrade_release() {
  local include_dir=""

  # Parse arguments
  while [ $# -gt 0 ]; do
    case "$1" in
      --include)
        shift
        include_dir="$1"
        shift
        ;;
      *)
        shift
        ;;
    esac
  done

  local local_jar_path=""
  local local_version=""
  if local_jar_path="$(find_latest_local_jar)"; then
    local_version="$(version_from_jar "$local_jar_path")"
  fi

  # Check for newer local jar in include directory
  local local_candidate=""
  if [ -n "$include_dir" ]; then
    if local_candidate="$(find_newest_jar_in_dir "$include_dir")"; then
      if [ -n "$local_jar_path" ]; then
        if is_newer_jar "$local_jar_path" "$local_candidate"; then
          echo "Found newer local jar: $(basename "$local_candidate")"
          install_local_jar "$local_candidate"
          return
        fi
      else
        echo "Found local jar: $(basename "$local_candidate")"
        install_local_jar "$local_candidate"
        return
      fi
    fi
  fi

  fetch_release_info
  if [ -z "$local_version" ]; then
    download_latest_release >/dev/null
    return
  fi
  if is_newer_version "$local_version" "$LATEST_VERSION"; then
    download_latest_release
    remove_old_jars "$LATEST_VERSION"
  else
    echo "You are already using the latest version of the local coding assistant (${local_version})"
  fi
}

install_local_jar() {
  local source_jar="$1"
  if [ -z "$source_jar" ]; then
    die "Usage: lca install <path-to-jar>"
  fi
  if [ ! -f "$source_jar" ]; then
    die "File not found: $source_jar"
  fi
  local jar_name
  jar_name="$(basename "$source_jar")"
  if [[ ! "$jar_name" =~ ^${JAR_PREFIX}-.*-exec\.jar$ ]]; then
    die "Invalid jar name. Expected pattern: ${JAR_PREFIX}-VERSION-exec.jar"
  fi
  local new_version
  new_version="$(printf '%s\n' "$jar_name" | sed -E 's/^local-coding-assistant-(.*)-exec\.jar$/\1/')"
  mkdir -p "$LIB_DIR"
  local target_path="${LIB_DIR}/${jar_name}"
  echo "Installing ${jar_name} to ${LIB_DIR}..."
  cp "$source_jar" "$target_path"
  remove_old_jars "$new_version"
  echo "Successfully installed ${jar_name}"
}

case "${1:-}" in
  upgrade)
    shift
    upgrade_release "$@"
    ;;
  install)
    shift
    install_local_jar "$@"
    ;;
  -h|--help|help)
    usage
    ;;
  *)
    run_programme "$@"
    ;;
esac
